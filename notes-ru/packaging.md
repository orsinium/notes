

## setuptools

Когда я только начал изучать питон, я сделал свой первый проект. И я захотел, чтобы проект стал пакетом, который можно скачать и установить с pypi.org. Что для этого нужно?

Нужно создать [вот такой файл](https://docs.python.org/3/distutils/introduction.html#a-simple-example):

```python
from distutils.core import setup
setup(name='foo',
      version='1.0',
      py_modules=['foo'],
      )
```

Я сохранил оригинальное форматирование из документации `distutils`, чтобы вы почувствовали дух питона, свободного от кодстайлов. `Distutils` состоит из плохих решений, таких как глобальные переменные и ненужное дублирование кода. Но главное плохое решение, что это не инструмент, который умеет читать метаданные и работать с ними, а скрипт, который можно только исполнить. Соответственно, эти метаданные невозможно прочитать, не исполнив скрипт, а исполнения скрипта может быть довольно болезненным: нужно создать окружение, поместить туда все файлы проекта (потому что что-то из этого может понадобиться скрипту), установить зависимости, нужные для скрипты, запустить его и понадеяться, что это не отправит куда-нибудь ssh-ключи текущего пользователя. Причём даже этого ещё недостаточно, потому что в `distutils` нет команды, чтобы получить метаданные, можно только исполнять с ними разные действия, такие как сборка пакета или установка зависимостей. Думаю, это то самое решение, которое сильно повлияло на дальнейшую судьбу пакетов в питоне.

К тому же, у `distutils` есть ещё один огромный недостаток: он в стандартной библиотеке. Казалось бы, а где же ему быть ещё, но это накладывает множество ограничений: сложно контрибьютить, релизы привязаны к релизам питона, нужно всеми силами соханять обратную совместимость. Решением стал `setuptools` -- обёртка вокруг `distutils`, добавляющая новые команды, новые поля в метаданных. Но интерфейс и архитектура остались всё те же, а соответственно всё те же проблемы. Например, установленные через него пакеты нельзя удалить. Теперь именно он используется во всех `setup.py` и точно установлен в каждом вашем окружении.

## setup.cfg

Ещё одна интересная попытка починить все проблемы `distutils` и многие другие, о которых я расскажу дальше, была предпринята в проекте [distutils2](https://pypi.org/project/Distutils2/). Его планировали как включить в Python 3.3 под красивым именем `packaging`, так и сделать доступным на pypi в качестве бэкпорта. В итоге идею забросили в пользу `venv`, `setuptools` и `pip`, но задумка была интересная.

Но `distutils2` всё-таки оказал некоторое влияние на то, с чем мы живём сейчас. В 2009 году был написан [PEP-390](https://www.python.org/dev/peps/pep-0390/), описывающий формат `setup.cfg`. Идея была простая: сделать возможность получать метаданные проекта бех его установки или исполнения скриптов. Формат cfg такое себе, потому что он совершенно не гибкий и не стандартизованный, но всё равно, это была отличная идея. PEP в 2013 году отвергли, потому что `distutils2` умер, однако в 2016 году поддержку этого формата [добавили](https://setuptools.readthedocs.io/en/latest/setuptools.html#configuring-setup-using-setup-cfg-files) в `setuptools`.

## sdist

Sdist -- это `tar.gz` архив c кодом пакета и всеми его метаданными. Именно он скачивается с pypi. Формат развивался давно и стихийно, а потому и выглядит крайне занимательно. Внутри лежит директория с названием проекта и его версией, а в этой директории все нужные файлы, такие как README и LICENSE, папки с кодом проекта, иногда тесты, и директория `project_name.egg-info`. Давайте посмотрим, что в ней.

+ `PKG-INFO` -- основные метаданный проекта. Здесь название и версия проекта, описание, homepage и прочее. В общем, почти всё то же самое, что указывается в setup.py. Из интересного ключ `Provides-Extra` который перечисляет, какие у пакета есть extra зависимости. Но самое интересное -- формат файла. Это email сообщение.
+ `requires.txt` -- файл с зависимостями. Кастомный формат, немного напоминает ini. Зависимости описаны примерно как в requirments.txt и разделены на секции. Название секции -- имя extra группы. В начале идут не-extra зависимости, без секции.
+ `entry_point.txt` -- а фот это уже настоящий ini с точками входа в приложение. Entry points позволяют регистрировать консольные команды и плагины для всяких штук типа pytest и flake8.
+ `dependency_links.txt` -- тут указываются ссылки на зависимости, которые нужно забрать не с pypi. Это может быть URL или путь к архиву или скрипту.
+ `SOURCES.txt` -- список всех файлов в архиве.
+ Ну и ещё несколько неинтересных файлов.

В общем, внутри целый зоопарк разных файлов. Все в разных форматах, некоторые пустые, какие-то могут отсутствовать. Sdist -- очень некрасивый и неэффективный формат, и у меня вызывает только грусть.

## wheel

Но не всё так плохо! Sdist в 2012 году решили починить! Появился формат wheel, призванный исправить все проблемы sdist. Он позволил быстрее ставить пакеты, складывать в них скомпилированные C библиотеки, заложил информацию о платформе в название архива. А ещё теперь это zip. Давайте посмотрим, как починили метаданные.

+ `METADATA`. В PEP написано, что это прям то же самое, что и `PKG-INFO`. Верите? Не надо верить.
  + Описание пакета теперь не один из заголовков, а тело сообщения. Вы же помните, что у нас формат -- это email письмо?
  + Появился заголовок `Requires-Dist`, теперь зависимости описаны в нём. Вроде бы, неплохое изменение, но парсить это стало сильно больнее. Всё дело в том, что extra группа для зависимостей, которая рагьше была именем секции, теперь указывается как маркер.
+ `RECORD` -- список всех файлов, как и `SOURCES.txt`, но только теперь тут ещё хэши указаны.

Всё остальное то же самое. Остались `dependency_links.txt` (только теперь файл можно не записывать, если он пустой), остались `entry_points.txt`. Про существование JSON никто так и не вспомнил.

## pypi.org

pypi.org - центральное хранилище Python пакетов, откуда их можно скачать и установить. Он существует с 2003 года и побывал на разных адресах:

+ 2003-2007: python.org/pypi
+ 2007-2017: pypi.python.org
+ 2017-сейчас: pypi.org

Изначально он назывался CheeseShop, сейчас же обрёл более солидное название Warehouse. Ещё довольно примечательно, что с 2006-2007 годах в него всё хотели встроить cheesecake (pycheesecake.org) -- инструмент, для оценки кода по 3 критериям: Installability, Documentation, Code kwalitee (sic!). Был сайт с рейтингом всех пакетов: pypi.pycheesecake.org. Первое место в рейтинге качества кода гордо занимал pylint. Сейчас все ссылки уже мертвы, и я не знаю, что стало с проектом, но internet wayback machine всё помнит.

## pip

## lockfile

## pip-tools

## pipenv

## poetry

## flit
