

## setuptools

Когда я только начал изучать питон, я сделал свой первый проект. И я захотел, чтобы проект стал пакетом, который можно скачать и установить с pypi.org. Что для этого нужно?

Нужно создать [вот такой файл](https://docs.python.org/3/distutils/introduction.html#a-simple-example):

```python
from distutils.core import setup
setup(name='foo',
      version='1.0',
      py_modules=['foo'],
      )
```

Я сохранил оригинальное форматирование из документации `distutils`, чтобы вы почувствовали дух питона, свободного от кодстайлов. `Distutils` состоит из плохих решений, таких как глобальные переменные и ненужное дублирование кода. Но главное плохое решение, что это не инструмент, который умеет читать метаданные и работать с ними, а скрипт, который можно только исполнить. Соответственно, эти метаданные невозможно прочитать, не исполнив скрипт, а исполнения скрипта может быть довольно болезненным: нужно создать окружение, поместить туда все файлы проекта (потому что что-то из этого может понадобиться скрипту), установить зависимости, нужные для скрипты, запустить его и понадеяться, что это не отправит куда-нибудь ssh-ключи текущего пользователя. Причём даже этого ещё недостаточно, потому что в `distutils` нет команды, чтобы получить метаданные, можно только исполнять с ними разные действия, такие как сборка пакета или установка зависимостей. Думаю, это то самое решение, которое сильно повлияло на дальнейшую судьбу пакетов в питоне.

К тому же, у `distutils` есть ещё один огромный недостаток: он в стандартной библиотеке. Казалось бы, а где же ему быть ещё, но это накладывает множество ограничений: сложно контрибьютить, релизы привязаны к релизам питона, нужно всеми силами соханять обратную совместимость. Решением стал `setuptools` -- обёртка вокруг `distutils`, добавляющая новые команды, новые поля в метаданных. Но интерфейс и архитектура остались всё те же, а соответственно всё те же проблемы. Например, установленные через него пакеты нельзя удалить. Теперь именно он используется во всех `setup.py` и точно установлен в каждом вашем окружении.

## setup.cfg

Ещё одна интересная попытка починить все проблемы `distutils` и многие другие, о которых я расскажу дальше, была предпринята в проекте [distutils2](https://pypi.org/project/Distutils2/). Его планировали как включить в Python 3.3 под красивым именем `packaging`, так и сделать доступным на pypi в качестве бэкпорта. В итоге идею забросили в пользу `venv`, `setuptools` и `pip`, но задумка была интересная.

Но `distutils2` всё-таки оказал некоторое влияние на то, с чем мы живём сейчас. В 2009 году был написан [PEP-390](https://www.python.org/dev/peps/pep-0390/), описывающий формат `setup.cfg`. Идея была простая: сделать возможность получать метаданные проекта бех его установки или исполнения скриптов. Формат cfg такое себе, потому что он совершенно не гибкий и не стандартизованный, но всё равно, это была отличная идея. PEP в 2013 году отвергли, потому что `distutils2` умер, однако в 2016 году поддержку этого формата [добавили](https://setuptools.readthedocs.io/en/latest/setuptools.html#configuring-setup-using-setup-cfg-files) в `setuptools`.

## sdist

## wheel

## pip

## lockfile

## pip-tools

## pipenv

## poetry

## flit
